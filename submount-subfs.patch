--- submount-0.9/subfs-0.9/subfs.c.orig	2004-02-26 23:54:58.000000000 +0100
+++ submount-0.9/subfs-0.9/subfs.c	2006-10-19 02:24:11.987932309 +0200
@@ -25,6 +25,8 @@
 #include <asm/signal.h>
 #include <linux/signal.h>
 #include <linux/sched.h>
+#include <linux/version.h>
+#include <linux/rcupdate.h>
 
 #include "subfs.h"
 
@@ -94,11 +96,19 @@
 	struct task_struct *task = current;
 	int signal = SIGCONT;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
 	read_lock(&tasklist_lock);
 	spin_lock_irq(&task->sighand->siglock);
 	sigaddset(&task->pending.signal, signal);
 	spin_unlock_irq(&task->sighand->siglock);
 	read_unlock(&tasklist_lock);
+#else
+	rcu_read_lock();
+	spin_lock_irq(&task->sighand->siglock);
+	sigaddset(&task->pending.signal, signal);
+	spin_unlock_irq(&task->sighand->siglock);
+	rcu_read_unlock();
+#endif
 	set_tsk_thread_flag(task, TIF_SIGPENDING);
 	return;
 }
@@ -187,11 +197,11 @@
 	if (&sfs_mnt->mount->mnt_mounts == sfs_mnt->mount->mnt_mounts.next) {
 		result = mount_real_fs(sfs_mnt);
 		if (result) {
-			ERR("subfs: submountd execution failure. Error %d\n",
-			       result);
 			/* Workaround for call_usermodehelper return value bug. */
-			if(result < 0)
+			if(result < 0) {
+				ERR("subfs: submountd execution failure. Error %d\n", result);
 				return ERR_PTR(result);
+			}
 			return ERR_PTR(-ENOMEDIUM);
 		}
 		if (&sfs_mnt->mount->mnt_mounts
@@ -221,6 +231,7 @@
 	struct vfsmount *child;
 
 	/* This is ugly, but prevents a lockup during mount. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
 	up(&dir->i_sem);
 	if (down_interruptible(&sfs_mnt->sem)) {
 		down(&dir->i_sem);/*put the dir sem back down if interrupted*/
@@ -229,6 +240,16 @@
 	child = get_child_mount(sfs_mnt);
 	up(&sfs_mnt->sem);
 	down(&dir->i_sem);
+#else
+	mutex_lock(&dir->i_mutex);
+	if (down_interruptible(&sfs_mnt->sem)) {
+		mutex_unlock(&dir->i_mutex);
+		return ERR_PTR(-ERESTARTSYS);
+	}
+	child = get_child_mount(sfs_mnt);
+	up(&sfs_mnt->sem);
+	mutex_unlock(&dir->i_mutex);
+#endif
 	if (IS_ERR(child))
 		return (void *) child;
 	subfs_send_signal();
@@ -262,9 +283,15 @@
 
 /*  Implements the statfs method so df and such will work on the mountpoint.
  */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 static int subfs_statfs(struct super_block *sb, struct kstatfs *buf)
 {
 	struct subfs_mount *sfs_mnt = sb->s_fs_info;
+#else
+static int subfs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct subfs_mount *sfs_mnt = dentry->d_sb->s_fs_info;
+#endif
 	struct vfsmount *child;
 	if (down_interruptible(&sfs_mnt->sem))
 		return -ERESTARTSYS;
@@ -388,6 +415,7 @@
  * subfs_mount structure is pointed to by the s_fs_info field of the
  * superblock structure.
  */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 static struct super_block *subfs_get_super(struct file_system_type *fst,
 				int flags, const char *devname, void *data)
 {
@@ -416,7 +444,39 @@
 	newmount->sb->s_fs_info = newmount;
 	return newmount->sb;
 }
+#else
+static int subfs_get_super(struct file_system_type *fst,
+				int flags, const char *devname, void *data,
+				struct vfsmount *mnt)
+{
+	char *device;
+	struct subfs_mount *newmount;
+	int ret;
 
+	if (!(newmount = kmalloc(sizeof(struct subfs_mount), GFP_KERNEL)))
+		return -ENOMEM;
+	newmount->req_fs = NULL;
+	newmount->sb = NULL;
+	newmount->mount = NULL;
+	newmount->procuid = 0;
+	sema_init(&newmount->sem, 1);
+	if (!(device = kmalloc((strlen(devname) + 1), GFP_KERNEL)))
+		return -ENOMEM;
+	strcpy(device, devname);
+	newmount->device = device;
+        if (!(newmount->helper_prog =
+        		kmalloc(sizeof(SUBMOUNTD_PATH), GFP_KERNEL)))
+		return -ENOMEM;
+	strcpy(newmount->helper_prog, SUBMOUNTD_PATH);
+	if ((ret = proc_opts(newmount, data)))
+		return ret;
+	if ((ret = get_sb_nodev(fst, flags, data, subfs_fill_super, mnt)))
+		return ret;
+	newmount->sb = mnt->mnt_sb;
+	newmount->sb->s_fs_info = newmount;
+	return ret;
+}
+#endif
 
 /* subfs_kill_super is the subfs implementation of the kill_sb method.
  * It should be called only on umount.  It cleans up the appropriate
--- submount-0.9/subfs-0.9/subfs.h.orig	2004-02-26 23:54:58.000000000 +0100
+++ submount-0.9/subfs-0.9/subfs.h	2006-10-19 02:14:56.944311764 +0200
@@ -33,8 +33,17 @@
 
 
 static void subfs_kill_super(struct super_block *sb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 static struct super_block *subfs_get_super(struct file_system_type *fst,
 		int flags, const char *devname, void *data);
+static int subfs_statfs(struct super_block *sb, struct kstatfs *buf);
+#else
+static int subfs_get_super(struct file_system_type *fst,
+		int flags, const char *devname, void *data, struct vfsmount *mnt);
+static int subfs_statfs(struct dentry *dentry, struct kstatfs *buf);
+#endif
+
 static struct vfsmount *get_subfs_vfsmount(struct super_block *sb);
 static int subfs_fill_super(struct super_block *sb, void *data,
 			    int silent);
@@ -47,8 +56,6 @@
 static void subfs_send_signal(void);
 static void subfs_set_fs_pwd(struct fs_struct *fs, struct vfsmount *mnt,
 			     struct dentry *dentry);
-static int subfs_statfs(struct super_block *sb, struct kstatfs *buf);
-
 
 static struct file_system_type subfs_type = {
 	.owner = THIS_MODULE,
